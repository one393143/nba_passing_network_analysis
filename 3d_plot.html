<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>NBA Analytics Hub</title>
    
    <!-- 1. Load Libraries via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      body { font-family: 'Inter', sans-serif; }
      .custom-scrollbar::-webkit-scrollbar { width: 8px; height: 8px; }
      .custom-scrollbar::-webkit-scrollbar-track { background: #f1f1f1; }
      .custom-scrollbar::-webkit-scrollbar-thumb { background: #888; border-radius: 4px; }
      .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #555; }
      .no-select { user-select: none; -webkit-user-select: none; }
    </style>
<script type="importmap">
{
  "imports": {
    "@vitejs/plugin-react": "https://aistudiocdn.com/@vitejs/plugin-react@^5.1.1",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "vite": "https://aistudiocdn.com/vite@^7.2.2",
    "d3": "https://aistudiocdn.com/d3@^7.9.0"
  }
}
</script>
<link rel="stylesheet" href="/index.css">
</head>
<body class="bg-gray-50 text-gray-900">
    <div id="root"></div>

    <!-- 2. Application Code -->
    <script type="text/babel" data-presets="react">
        const { useState, useEffect, useRef, useMemo } = React;
        const { createRoot } = ReactDOM;

        // --- Icons ---
        const Icons = {
            Database: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><ellipse cx="12" cy="5" rx="9" ry="3"/><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"/><path d="M3 5v14c0 1.66 4 3 9 3s 9-1.34 9-3V5"/></svg>,
            Network: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="18" cy="5" r="3"/><circle cx="6" cy="12" r="3"/><circle cx="18" cy="19" r="3"/><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/></svg>,
            Loader: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="animate-spin"><path d="M21 12a9 9 0 1 1-6.219-8.56"/></svg>,
            AlertCircle: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="12"/><line x1="12" y1="16" x2="12.01" y2="16"/></svg>,
            Link: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg>,
            Calendar: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>,
            FileText: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>,
            Rotate3D: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 3a9 9 0 1 0 9 9"></path><path d="M12 3v6"></path><path d="M21 12h-6"></path></svg>,
            Upload: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>,
            Play: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>,
            Stop: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>
        };

        // --- Configuration ---
        const REPO_BASE = "https://raw.githubusercontent.com/one393143/nba_passing_network_analysis/refs/heads/main/data";
        const NBA_HEADSHOT_URL = (id) => `https://cdn.nba.com/headshots/nba/latest/260x190/${id}.png`;

        const getSeasonString = (year) => {
            const nextYear = (year + 1) % 100;
            return `${year}-${nextYear.toString().padStart(2, '0')}`;
        };

        const YEARS_RANGE = Array.from({ length: 10 }, (_, i) => 2015 + i);

        const DATA_SOURCES = [
            { id: 'passes_pergame', name: 'Passes Per Game (Yearly)', folder: 'passes_pergame', years: YEARS_RANGE, filename: (year) => `all_players_pass_data_${year}.csv` },
            { id: 'performance_player_pergame', name: 'Player Game Performance (Yearly)', folder: 'performance_player_pergame', years: YEARS_RANGE, filename: (year) => `${getSeasonString(year)}_player_game_data.csv` },
            { id: 'performance_player_season', name: 'Player Season Stats (Yearly)', folder: 'performance_player_season', years: YEARS_RANGE, filename: (year) => `${getSeasonString(year)}_all_players.csv` },
            { id: 'team_game_stats', name: 'Team Game Stats (All Time)', folder: 'performance_team_pergame', years: [], filename: () => `all_seasons_all_games_team_stats.csv` },
            { id: 'team_regular_season', name: 'Team Regular Season Stats (2015-2024)', folder: 'performance_team', years: [], filename: () => `nba_regular_season_stats_2015_to_2024.csv` },
            { id: 'team_playoff', name: 'Team Playoff Stats (2015-2024)', folder: 'performance_team', years: [], filename: () => `nba_playoff_stats_2015_to_2024.csv` },
            { id: 'team_standings', name: 'League Standings (2015-2024)', folder: 'performance_team', years: [], filename: () => `nba_league_standings_2015_to_2024.csv` },
            { id: 'salary', name: 'Player Salaries', folder: 'players_detailed', years: [], filename: () => `salary from br.csv` }
        ];

        // --- CSV Parser ---
        const parseCSV = (text) => {
            const lines = text.trim().split('\n');
            if (lines.length === 0) return { headers: [], data: [] };
            
            const parseLine = (line) => {
                return line.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/).map(val => {
                    return val.trim().replace(/^"|"$/g, '').replace(/""/g, '"');
                });
            };
            
            const headers = parseLine(lines[0]);
            const data = [];
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i];
                if (!line.trim()) continue;
                const values = parseLine(line);
                if (values.length >= headers.length) {
                    const entry = {};
                    headers.forEach((header, index) => { entry[header] = values[index] || ''; });
                    data.push(entry);
                }
            }
            return { headers, data };
        };

        // --- Data Explorer Component ---
        const DataExplorer = () => {
            const [selectedSourceId, setSelectedSourceId] = useState(DATA_SOURCES[0].id);
            const [selectedYear, setSelectedYear] = useState(DATA_SOURCES[0].years[0]);
            const [urlInput, setUrlInput] = useState('');
            const [csvData, setCsvData] = useState(null);
            const [loading, setLoading] = useState(false);
            const [error, setError] = useState(null);
            const [currentPage, setCurrentPage] = useState(1);
            const rowsPerPage = 50;

            const currentSource = DATA_SOURCES.find(s => s.id === selectedSourceId) || DATA_SOURCES[0];
            const isStaticSource = currentSource.years.length === 0;

            useEffect(() => {
                const filename = currentSource.filename(selectedYear);
                const newUrl = `${REPO_BASE}/${currentSource.folder}/${encodeURIComponent(filename)}`;
                setUrlInput(newUrl);
                loadData(newUrl);
            }, [selectedSourceId, selectedYear]);

            const loadData = async (url) => {
                if (!url.trim()) return;
                try {
                    setLoading(true);
                    setError(null);
                    const response = await fetch(url.trim());
                    if (!response.ok) throw new Error(`Failed to fetch (${response.status}). Network blocks?`);
                    const text = await response.text();
                    const parsed = parseCSV(text);
                    if (parsed.headers.length === 0) throw new Error('Parsed data is empty.');
                    setCsvData(parsed);
                    setCurrentPage(1);
                } catch (err) {
                    console.error(err);
                    setError(err.message || 'Error loading CSV.');
                    setCsvData(null);
                } finally {
                    setLoading(false);
                }
            };

            const handleFileUpload = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                setLoading(true);
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const text = event.target.result;
                        const parsed = parseCSV(text);
                        if (parsed.headers.length === 0) throw new Error('File is empty or invalid.');
                        setCsvData(parsed);
                        setError(null);
                        setCurrentPage(1);
                    } catch(err) {
                        setError("Failed to parse file: " + err.message);
                    } finally {
                        setLoading(false);
                    }
                };
                reader.onerror = () => {
                    setError("Error reading file.");
                    setLoading(false);
                }
                reader.readAsText(file);
            };

            const handleFormSubmit = (e) => {
                e.preventDefault();
                loadData(urlInput);
            };

            const handleSourceChange = (e) => {
                const newSourceId = e.target.value;
                const newSource = DATA_SOURCES.find(s => s.id === newSourceId);
                if (newSource) {
                    setSelectedSourceId(newSourceId);
                    if (newSource.years.length > 0 && !newSource.years.includes(selectedYear)) {
                        setSelectedYear(newSource.years[0]);
                    }
                }
            };

            const totalPages = csvData ? Math.ceil(csvData.data.length / rowsPerPage) : 0;
            const currentRows = csvData ? csvData.data.slice((currentPage - 1) * rowsPerPage, currentPage * rowsPerPage) : [];

            return (
                <div className="space-y-6">
                    <div className="flex flex-col lg:flex-row gap-4 bg-gray-50 p-4 rounded-lg border border-gray-200">
                        <div className="flex flex-col sm:flex-row gap-4 flex-1">
                            <div className="flex-1 min-w-[240px]">
                                <label className="block text-xs font-semibold text-gray-500 uppercase mb-1.5 flex items-center gap-1">
                                    <Icons.FileText /> Dataset
                                </label>
                                <select value={selectedSourceId} onChange={handleSourceChange} className="block w-full pl-3 pr-10 py-2 text-base border-gray-300 rounded-md border bg-white">
                                    {DATA_SOURCES.map(source => <option key={source.id} value={source.id}>{source.name}</option>)}
                                </select>
                            </div>
                            {!isStaticSource && (
                                <div className="w-full sm:w-40">
                                    <label className="block text-xs font-semibold text-gray-500 uppercase mb-1.5 flex items-center gap-1">
                                        <Icons.Calendar /> Season
                                    </label>
                                    <select value={selectedYear} onChange={(e) => setSelectedYear(Number(e.target.value))} className="block w-full pl-3 pr-10 py-2 text-base border-gray-300 rounded-md border bg-white">
                                        {currentSource.years.map(year => <option key={year} value={year}>{year} ({getSeasonString(year)})</option>)}
                                    </select>
                                </div>
                            )}
                        </div>
                        <div className="flex-1 flex flex-col">
                            <label className="block text-xs font-semibold text-gray-500 uppercase mb-1.5 flex items-center gap-1">
                                <Icons.Link /> Data URL
                            </label>
                             <form onSubmit={handleFormSubmit} className="flex gap-2">
                                <input type="text" value={urlInput} onChange={(e) => setUrlInput(e.target.value)} className="block w-full px-3 py-2 text-sm border border-gray-300 rounded-md bg-white text-gray-600" />
                                <button type="submit" disabled={loading} className="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 disabled:opacity-50">{loading ? 'Loading' : 'Load'}</button>
                             </form>
                        </div>
                    </div>
                    
                    {loading && <div className="flex justify-center p-12 text-gray-500"><div className="flex flex-col items-center gap-2"><Icons.Loader /><span>Loading data...</span></div></div>}
                    
                    {error && (
                        <div className="p-4 bg-red-50 border border-red-200 rounded-lg text-red-700 flex flex-col gap-3">
                            <div className="flex items-center gap-3">
                                <Icons.AlertCircle />
                                <span>{error}</span>
                            </div>
                            <div className="pl-9">
                                <p className="text-sm text-red-600 mb-2 font-medium">Network blocked? Upload the file manually:</p>
                                <label className="inline-flex items-center px-4 py-2 border border-gray-300 shadow-sm text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 cursor-pointer">
                                    <Icons.Upload />
                                    <span className="ml-2">Upload CSV/JSON</span>
                                    <input type="file" className="hidden" accept=".csv,.json,.txt" onChange={handleFileUpload} />
                                </label>
                            </div>
                        </div>
                    )}

                    {csvData && !loading && !error && (
                        <div className="border border-gray-200 rounded-lg overflow-hidden bg-white shadow-sm">
                            <div className="overflow-auto custom-scrollbar max-h-[600px]">
                                <table className="w-full text-sm text-left whitespace-nowrap">
                                    <thead className="text-xs text-gray-700 uppercase bg-gray-50 sticky top-0 z-10">
                                        <tr>{csvData.headers.map((header, i) => <th key={i} className="px-6 py-3 border-b border-gray-200 font-semibold">{header}</th>)}</tr>
                                    </thead>
                                    <tbody className="divide-y divide-gray-100">
                                        {currentRows.map((row, idx) => (
                                            <tr key={idx} className="hover:bg-blue-50/50 transition-colors">
                                                {csvData.headers.map((header, i) => <td key={i} className="px-6 py-2 text-gray-600">{row[header]}</td>)}
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                            <div className="p-3 border-t border-gray-200 bg-gray-50 flex justify-between items-center text-sm text-gray-600">
                                <span>Page {currentPage} of {totalPages}</span>
                                <div className="flex gap-2">
                                    <button onClick={() => setCurrentPage(Math.max(1, currentPage - 1))} disabled={currentPage === 1} className="px-3 py-1 border rounded bg-white hover:bg-gray-100 disabled:opacity-50">Prev</button>
                                    <button onClick={() => setCurrentPage(Math.min(totalPages, currentPage + 1))} disabled={currentPage === totalPages} className="px-3 py-1 border rounded bg-white hover:bg-gray-100 disabled:opacity-50">Next</button>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // --- Network Visualizer Component ---
        const NetworkVisualizer = () => {
            const [selectedYear, setSelectedYear] = useState(2024);
            const [loading, setLoading] = useState(false);
            const [fetchError, setFetchError] = useState(null);
            const [csvData, setCsvData] = useState([]);
            const [teams, setTeams] = useState([]);
            const [selectedTeamId, setSelectedTeamId] = useState('');
            const [dateRange, setDateRange] = useState({start: '', end: ''});
            const [minMaxDate, setMinMaxDate] = useState({min: '', max: ''});
            
            // Modes
            const [isPreviewMode, setIsPreviewMode] = useState(false);

            // 3D Controls
            const [rotation, setRotation] = useState({ x: 0, y: 0, z: 0 });
            const [autoRotate, setAutoRotate] = useState(false);

            const svgRef = useRef(null);

            const formatName = (lastFirst) => {
                if (!lastFirst) return "Unknown";
                const parts = lastFirst.split(',');
                if (parts.length === 2) return `${parts[1].trim()} ${parts[0].trim()}`;
                return lastFirst;
            };

            const processData = (parsedData) => {
                setCsvData(parsedData);
                const uniqueTeams = new Map();
                const dates = [];
                parsedData.forEach(row => {
                    if (row.TEAM_ID && row.TEAM_NAME) uniqueTeams.set(row.TEAM_ID, row.TEAM_NAME);
                    if (row.GAME_DATE) dates.push(row.GAME_DATE);
                });
                
                const teamList = Array.from(uniqueTeams.entries()).map(([id, name]) => ({ id, name })).sort((a, b) => a.name.localeCompare(b.name));
                setTeams(teamList);
                if (teamList.length > 0) setSelectedTeamId(prev => teamList.find(t => t.id === prev)?.id || teamList[0].id);

                dates.sort();
                if (dates.length > 0) {
                    const min = dates[0];
                    const max = dates[dates.length - 1];
                    setMinMaxDate({ min, max });
                    setDateRange({ start: min, end: max });
                }
            };

            useEffect(() => {
                const loadSeasonData = async () => {
                    setLoading(true);
                    setFetchError(null);
                    try {
                        const filename = `all_players_pass_data_${selectedYear}.csv`;
                        // Manually constructing URL for passes_pergame folder
                        const finalUrl = `${REPO_BASE}/passes_pergame/${filename}`;
                        
                        const response = await fetch(finalUrl);
                        if (!response.ok) throw new Error('Network block');
                        const text = await response.text();
                        
                        const parsed = parseCSV(text);
                        processData(parsed.data);
                    } catch (e) {
                        console.error(e);
                        setFetchError(true);
                    } finally {
                        setLoading(false);
                    }
                };
                loadSeasonData();
            }, [selectedYear]);

            const handleFileUpload = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                setLoading(true);
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const text = event.target.result;
                        const parsed = parseCSV(text);
                        if(parsed.data && parsed.data.length > 0) {
                            processData(parsed.data);
                            setFetchError(null);
                        }
                    } catch(err) {
                        console.error(err);
                        alert("Failed to parse file");
                    } finally {
                        setLoading(false);
                    }
                };
                reader.readAsText(file);
            };

            // Reset rotation when switching modes
            useEffect(() => {
                if (isPreviewMode) {
                    setAutoRotate(true);
                    setRotation({x: 15, y: 0, z: 0}); // Slight tilt for floor visibility
                } else {
                    setAutoRotate(false);
                    setRotation({x: 0, y: 0, z: 0});
                }
            }, [isPreviewMode]);

            const graphData = useMemo(() => {
                if (!selectedTeamId || csvData.length === 0) return { nodes: [], links: [] };
                
                const filtered = csvData.filter(row => {
                    if (row.TEAM_ID !== selectedTeamId) return false;
                    if (dateRange.start && row.GAME_DATE < dateRange.start) return false;
                    if (dateRange.end && row.GAME_DATE > dateRange.end) return false;
                    return true;
                });

                const nodeMap = new Map();
                const linkMap = new Map();

                filtered.forEach(row => {
                    const sourceId = row.PLAYER_ID;
                    const targetId = row.PASS_TEAMMATE_PLAYER_ID;
                    const passes = parseInt(row.PASS || '0', 10);
                    const assists = parseInt(row.AST || '0', 10);

                    if (!nodeMap.has(sourceId)) nodeMap.set(sourceId, { id: sourceId, name: formatName(row.PLAYER_NAME_LAST_FIRST), assists: 0, z: (Math.random() - 0.5) * 400 });
                    if (!nodeMap.has(targetId)) nodeMap.set(targetId, { id: targetId, name: formatName(row.PASS_TO), assists: 0, z: (Math.random() - 0.5) * 400 });

                    nodeMap.get(sourceId).assists += assists;

                    const linkKey = `${sourceId}->${targetId}`;
                    if (!linkMap.has(linkKey)) linkMap.set(linkKey, { source: sourceId, target: targetId, weight: 0, assists: 0 });
                    linkMap.get(linkKey).weight += passes;
                    linkMap.get(linkKey).assists += assists;
                });

                return { nodes: Array.from(nodeMap.values()), links: Array.from(linkMap.values()).filter(l => l.weight > 0) };
            }, [selectedTeamId, dateRange, csvData]);

            const project3D = (x, y, z, angleX, angleY, angleZ, centerX, centerY) => {
                const radX = angleX * Math.PI / 180;
                const radY = angleY * Math.PI / 180;
                const radZ = angleZ * Math.PI / 180;

                let x1 = x * Math.cos(radY) - z * Math.sin(radY);
                let z1 = z * Math.cos(radY) + x * Math.sin(radY);

                let y1 = y * Math.cos(radX) - z1 * Math.sin(radX);
                let z2 = z1 * Math.cos(radX) + y * Math.sin(radX);

                let x2 = x1 * Math.cos(radZ) - y1 * Math.sin(radZ);
                let y2 = y1 * Math.cos(radZ) + x1 * Math.sin(radZ);

                const focalLength = 1000;
                const scale = focalLength / (focalLength + z2);
                return { x: x2 * scale + centerX, y: y2 * scale + centerY, scale: scale, depth: z2 };
            };

            // D3 Render Logic
            useEffect(() => {
                if (!svgRef.current || graphData.nodes.length === 0) return;

                const width = 1000;
                const height = 800;
                const svg = d3.select(svgRef.current);
                svg.selectAll("*").remove();

                // Track selection state
                let selectedNodeId = null;

                // Setup Defs
                const defs = svg.append("defs");
                const createMarker = (id, color) => {
                    defs.append("marker").attr("id", id).attr("viewBox", "0 -5 10 10").attr("refX", 24).attr("refY", 0).attr("markerWidth", 6).attr("markerHeight", 6).attr("orient", "auto").append("path").attr("d", "M0,-5L10,0L0,5").attr("fill", color);
                };
                createMarker("arrow-normal", "#9ca3af");
                createMarker("arrow-out", "#22c55e");
                createMarker("arrow-in", "#ef4444");
                createMarker("arrow-hover", "#f59e0b");

                const gradient = defs.append("radialGradient").attr("id", "sphere-shine").attr("cx", "35%").attr("cy", "35%").attr("r", "60%").attr("fx", "30%").attr("fy", "30%");
                gradient.append("stop").attr("offset", "0%").attr("stop-color", "#fff").attr("stop-opacity", 0.4);
                gradient.append("stop").attr("offset", "40%").attr("stop-color", "#fff").attr("stop-opacity", 0);
                gradient.append("stop").attr("offset", "100%").attr("stop-color", "#000").attr("stop-opacity", 0.4);

                // Shadow blur filter
                const blurFilter = defs.append("filter").attr("id", "blur-shadow").append("feGaussianBlur").attr("stdDeviation", 8);

                if (isPreviewMode) {
                    graphData.nodes.forEach(node => {
                         defs.append("clipPath").attr("id", `clip-${node.id}`).append("circle").attr("r", 35).attr("cx", 0).attr("cy", 0);
                    });
                }

                // Setup Grid Data (Floor)
                const gridLines = [];
                const gridSize = 1200;
                const gridStep = 150;
                const gridY = 400; // Floor Y level

                for (let i = -gridSize; i <= gridSize; i += gridStep) {
                    gridLines.push({ x1: -gridSize, y1: gridY, z1: i, x2: gridSize, y2: gridY, z2: i });
                    gridLines.push({ x1: i, y1: gridY, z1: -gridSize, x2: i, y2: gridY, z2: gridSize });
                }

                const zoomGroup = svg.append("g");
                
                // Background click to clear selection
                zoomGroup.append("rect")
                    .attr("x", -width * 2)
                    .attr("y", -height * 2)
                    .attr("width", width * 4)
                    .attr("height", height * 4)
                    .attr("fill", "transparent")
                    .on("click", () => {
                        selectedNodeId = null;
                        updateHighlights();
                    });

                if (!isPreviewMode) {
                    const zoom = d3.zoom().scaleExtent([0.5, 3]).on("zoom", (e) => zoomGroup.attr("transform", e.transform));
                    svg.call(zoom);
                }

                const container = zoomGroup.append("g").attr("transform", `translate(${width/2}, ${height/2})`);
                
                // --- Render Elements Order: Grid -> Shadows -> Links -> Nodes -> Balls ---
                
                // 1. Grid
                const gridSelection = container.append("g").attr("class", "grid-group")
                    .selectAll("path").data(gridLines).enter().append("path")
                    .attr("stroke", "#94a3b8").attr("stroke-width", 1).attr("fill", "none");

                // 2. Shadows (One per node)
                let shadowSelection = container.append("g").attr("class", "shadow-group")
                    .selectAll("ellipse").data(graphData.nodes).enter().append("ellipse")
                    .attr("fill", "#000").attr("opacity", 0.2).attr("filter", "url(#blur-shadow)");

                // 3. Links
                let linkSelection = container.append("g").attr("class", "link-group")
                    .selectAll("g").data(graphData.links).enter().append("g");
                
                const linkPath = linkSelection.append("path").attr("class", "link")
                    .attr("fill", "none")
                    .attr("stroke", isPreviewMode ? "#ccc" : "#9ca3af")
                    .attr("stroke-opacity", isPreviewMode ? 0.1 : 0.2)
                    .attr("marker-end", isPreviewMode ? null : "url(#arrow-normal)");
                
                if (!isPreviewMode) {
                    linkSelection.append("text").attr("text-anchor", "middle").style("font-size", "10px").style("fill", "#4b5563").style("font-weight", "bold").style("opacity", 0).text(d => `${d.weight} P / ${d.assists} A`);
                }

                // Helper to update highlights (called on click)
                const updateHighlights = () => {
                    if (!selectedNodeId) {
                         // Reset to default
                         d3.selectAll(".node-stat").style("opacity", 0);
                         linkPath.attr("stroke", isPreviewMode ? "#ccc" : "#9ca3af")
                                 .attr("stroke-opacity", isPreviewMode ? 0.1 : 0.2)
                                 .attr("stroke-width", 1)
                                 .attr("marker-end", isPreviewMode ? null : "url(#arrow-normal)");
                         nodeSelection.style("opacity", 1);
                         // Reset node circles if needed (for non-preview mode)
                         if(!isPreviewMode) {
                             nodeSelection.select(".node-circle").attr("fill", "#87CEEB").attr("stroke", "#fff");
                             d3.selectAll(".link-group text").style("opacity", 0);
                         }
                         return;
                    }

                    // Dim Unrelated Nodes
                    nodeSelection.style("opacity", n => {
                         if (n.id === selectedNodeId) return 1;
                         const isNeighbor = graphData.links.some(l => 
                            (l.source.id === selectedNodeId && l.target.id === n.id) || 
                            (l.target.id === selectedNodeId && l.source.id === n.id)
                         );
                         return isNeighbor ? 1 : 0.1;
                    });

                    // Show Stats for Selected
                    nodeSelection.filter(d => d.id === selectedNodeId).select(".node-stat").style("opacity", 1);
                    nodeSelection.filter(d => d.id !== selectedNodeId).select(".node-stat").style("opacity", 0);

                    if (!isPreviewMode) {
                        nodeSelection.filter(d => d.id === selectedNodeId).select(".node-circle").attr("fill", "#fbbf24").attr("stroke", "#000");
                        nodeSelection.filter(d => d.id !== selectedNodeId).select(".node-circle").attr("fill", "#87CEEB").attr("stroke", "#fff");
                    }

                    // Color Links
                    linkPath.each(function(l) {
                        const sel = d3.select(this);
                        const textSel = !isPreviewMode ? d3.select(this.parentNode).select("text") : null;
                        
                        if (l.source.id === selectedNodeId) {
                            sel.attr("stroke", "#22c55e").attr("stroke-opacity", 0.8).attr("stroke-width", 2).attr("marker-end", "url(#arrow-out)");
                            if(textSel) { textSel.style("opacity", 1).style("fill", "#15803d"); }
                        } else if (l.target.id === selectedNodeId) {
                            sel.attr("stroke", "#ef4444").attr("stroke-opacity", 0.8).attr("stroke-width", 2).attr("marker-end", "url(#arrow-in)");
                            if(textSel) { textSel.style("opacity", 1).style("fill", "#b91c1c"); }
                        } else {
                            sel.attr("stroke-opacity", 0.05);
                            if(textSel) { textSel.style("opacity", 0); }
                        }
                    });
                };

                // 4. Nodes
                let nodeSelection = container.append("g").attr("class", "node-group")
                    .selectAll("g").data(graphData.nodes).enter().append("g").attr("class", "node");
                
                // ... (Node Visuals logic)
                if (isPreviewMode) {
                     nodeSelection.append("circle").attr("r", 35).attr("fill", "#fff");
                     nodeSelection.append("image").attr("xlink:href", d => NBA_HEADSHOT_URL(d.id))
                         .attr("x", -35).attr("y", -35).attr("width", 70).attr("height", 70)
                         .attr("clip-path", d => `url(#clip-${d.id})`)
                         .style("cursor", "pointer") // Visual cue
                         .on("error", function() { d3.select(this).attr("visibility", "hidden"); });
                     nodeSelection.append("circle").attr("r", 35).attr("fill", "url(#sphere-shine)").style("pointer-events", "none");
                     nodeSelection.append("text").text(d => d.name).attr("class", "node-label").attr("text-anchor", "middle").attr("dy", 50).style("font-size", "14px").style("font-weight", "bold").style("fill", "#1f2937").style("text-shadow", "2px 0 #fff, -2px 0 #fff, 0 2px #fff, 0 -2px #fff, 1px 1px #fff, -1px -1px #fff, 1px -1px #fff, -1px 1px #fff");
                     nodeSelection.append("text").attr("class", "node-stat").text(d => `Ast: ${d.assists}`).attr("text-anchor", "middle").attr("dy", 65).style("font-size", "12px").style("fill", "#dc2626").style("font-weight", "bold").style("opacity", 0);

                     nodeSelection.on("click", function(e, d) {
                        e.stopPropagation();
                        // Toggle selection
                        selectedNodeId = (selectedNodeId === d.id) ? null : d.id;
                        updateHighlights();
                    });
                } else {
                    nodeSelection.append("circle").attr("class", "node-circle").attr("fill", "#87CEEB").attr("stroke", "#fff").attr("stroke-width", 2).style("cursor", "pointer");
                    nodeSelection.append("text").attr("class", "node-label").text(d => d.name).attr("text-anchor", "middle").attr("dominant-baseline", "middle").style("font-size", "12px").style("font-weight", "600").style("fill", "#1f2937").style("pointer-events", "none").style("text-shadow", "0px 0px 4px rgba(255,255,255,0.9)");
                    nodeSelection.append("text").attr("class", "node-stat").text(d => `Ast: ${d.assists}`).attr("text-anchor", "middle").style("font-size", "11px").style("fill", "#dc2626").style("font-weight", "bold").style("opacity", 0);
                    
                    nodeSelection.on("click", function(e, d) {
                        e.stopPropagation();
                        selectedNodeId = (selectedNodeId === d.id) ? null : d.id;
                        updateHighlights();
                    });
                }

                // Balls Container (Last to be on top)
                let ballSelection = container.append("g").attr("class", "balls-group").selectAll(".ball");

                const maxAssists = d3.max(graphData.nodes, d => d.assists) || 1;
                const nodeRadiusScale = d3.scaleLinear().domain([0, maxAssists]).range([15, 45]);
                const linkWidthScale = d3.scaleLinear().domain([1, d3.max(graphData.links, d => d.weight) || 1]).range([1, 6]);

                const simulation = d3.forceSimulation(graphData.nodes)
                    .force("link", d3.forceLink(graphData.links).id(d => d.id).distance(400))
                    .force("charge", d3.forceManyBody().strength(-400))
                    .force("center", d3.forceCenter(0, 0))
                    .force("collide", d3.forceCollide().radius(50));

                let activeBalls = [];
                let rotationY = rotation.y;
                let lastTime = 0;

                const renderFrame = (timestamp) => {
                    if (autoRotate) {
                        const dt = timestamp - lastTime;
                        if (lastTime > 0) rotationY = (rotationY + 0.05 * dt/16) % 360;
                        lastTime = timestamp;
                    } else {
                        rotationY = rotation.y;
                        lastTime = 0;
                    }
                    const rX = rotation.x, rZ = rotation.z;

                    // 1. Project Grid
                    gridSelection.attr("d", d => {
                        const p1 = project3D(d.x1, d.y1, d.z1, rX, rotationY, rZ, 0, 0);
                        const p2 = project3D(d.x2, d.y2, d.z2, rX, rotationY, rZ, 0, 0);
                        return `M${p1.x},${p1.y}L${p2.x},${p2.y}`;
                    }).attr("stroke-opacity", d => {
                        const p1 = project3D(d.x1, d.y1, d.z1, rX, rotationY, rZ, 0, 0);
                        return Math.max(0.05, p1.scale * 0.2); 
                    });

                    // 2. Project Nodes
                    graphData.nodes.forEach(n => {
                        const proj = project3D(n.x || 0, n.y || 0, n.z, rX, rotationY, rZ, 0, 0);
                        n.px = proj.x; n.py = proj.y; n.pz = proj.depth; n.scale = proj.scale;
                    });

                    // 3. Project Shadows (Floor)
                    shadowSelection.attr("cx", d => project3D(d.x || 0, gridY, d.z, rX, rotationY, rZ, 0, 0).x)
                        .attr("cy", d => project3D(d.x || 0, gridY, d.z, rX, rotationY, rZ, 0, 0).y)
                        .attr("rx", d => nodeRadiusScale(d.assists) * project3D(d.x, gridY, d.z, rX, rotationY, rZ, 0, 0).scale * 1.2)
                        .attr("ry", d => nodeRadiusScale(d.assists) * project3D(d.x, gridY, d.z, rX, rotationY, rZ, 0, 0).scale * 0.4);

                    // 4. Sort Depth
                    nodeSelection.sort((a, b) => b.pz - a.pz);
                    linkSelection.sort((a, b) => ((b.source.pz + b.target.pz) / 2) - ((a.source.pz + a.target.pz) / 2));

                    // 5. Update Visuals
                    nodeSelection.attr("transform", d => `translate(${d.px},${d.py}) scale(${d.scale})`)
                        .style("filter", d => `brightness(${0.7 + (d.scale * 0.4)})`);
                    
                    if (!isPreviewMode) {
                        nodeSelection.select("circle").attr("r", d => nodeRadiusScale(d.assists));
                        nodeSelection.select(".node-stat").attr("dy", d => nodeRadiusScale(d.assists) + 15);
                    }

                    // 6. Update Links
                    linkSelection.select("path").attr("d", d => {
                        const dx = d.target.px - d.source.px;
                        const dy = d.target.py - d.source.py;
                        const dr = Math.sqrt(dx * dx + dy * dy) * 1.5; 
                        d.pathCache = `M${d.source.px},${d.source.py}A${dr},${dr} 0 0,1 ${d.target.px},${d.target.py}`;
                        return d.pathCache;
                    }).attr("stroke-width", d => linkWidthScale(d.weight) * ((d.source.scale + d.target.scale)/2));

                    // 7. Update Balls
                    if (isPreviewMode) {
                         graphData.links.forEach((link, i) => {
                             if (Math.random() < (link.weight * 0.002)) {
                                 const assistRatio = link.weight > 0 ? (link.assists / link.weight) : 0;
                                 activeBalls.push({ 
                                     linkIndex: i, t: 0, speed: 0.01 + Math.random() * 0.005,
                                     sourcePz: link.source.pz, targetPz: link.target.pz,
                                     isAssist: Math.random() < assistRatio
                                 });
                             }
                         });
                         activeBalls.forEach(b => b.t += b.speed);
                         activeBalls = activeBalls.filter(b => b.t < 1);

                         ballSelection = container.select(".balls-group").selectAll(".ball").data(activeBalls);
                         ballSelection.exit().remove();
                         ballSelection.enter().append("circle").attr("class", "ball").attr("r", 5).attr("stroke", "rgba(0,0,0,0.5)").attr("stroke-width", 0.5).merge(ballSelection)
                            .attr("fill", b => b.isAssist ? "#22c55e" : "#f97316")
                            .attr("opacity", b => {
                                if (!selectedNodeId) return 1;
                                const link = graphData.links[b.linkIndex];
                                return (link.source.id === selectedNodeId || link.target.id === selectedNodeId) ? 1 : 0.05;
                            })
                            .attr("transform", b => {
                                const link = graphData.links[b.linkIndex];
                                const p0 = {x: link.source.px, y: link.source.py};
                                const p2 = {x: link.target.px, y: link.target.py};
                                const dx = p2.x - p0.x, dy = p2.y - p0.y, dist = Math.sqrt(dx*dx + dy*dy);
                                const mx = (p0.x + p2.x)/2, my = (p0.y + p2.y)/2;
                                const perpX = -dy/dist, perpY = dx/dist, curveMag = dist * 0.3; 
                                const cx = mx + perpX * curveMag, cy = my + perpY * curveMag;
                                const t = b.t, invT = 1 - t;
                                const x = (invT * invT * p0.x) + (2 * invT * t * cx) + (t * t * p2.x);
                                const y = (invT * invT * p0.y) + (2 * invT * t * cy) + (t * t * p2.y);
                                const depth = (b.sourcePz * invT) + (b.targetPz * t);
                                const scale = 1000 / (1000 + depth);
                                return `translate(${x},${y}) scale(${scale})`;
                            });
                    }
                };

                const timer = d3.timer((elapsed) => { renderFrame(elapsed); });
                return () => { timer.stop(); simulation.stop(); };
            }, [graphData, rotation, autoRotate, isPreviewMode]);

            const resetRotation = () => { setRotation({ x: 0, y: 0, z: 0 }); setAutoRotate(false); };

            return (
                <div className="space-y-6">
                    <div className="bg-white p-4 rounded-lg border border-gray-200 shadow-sm flex flex-wrap gap-4 items-end">
                        <div className="w-40">
                            <label className="block text-xs font-semibold text-gray-500 uppercase mb-1">Season</label>
                            <select value={selectedYear} onChange={e => setSelectedYear(Number(e.target.value))} className="block w-full border-gray-300 rounded-md shadow-sm py-2 border px-2">
                                {YEARS_RANGE.map(y => <option key={y} value={y}>{y} ({getSeasonString(y)})</option>)}
                            </select>
                        </div>
                        <div className="flex-1 min-w-[200px]">
                            <label className="block text-xs font-semibold text-gray-500 uppercase mb-1">Team</label>
                            <select value={selectedTeamId} onChange={e => setSelectedTeamId(e.target.value)} disabled={loading || teams.length === 0} className="block w-full border-gray-300 rounded-md shadow-sm py-2 border px-2 disabled:bg-gray-100">
                                {teams.length === 0 && <option>Loading teams...</option>}
                                {teams.map(t => <option key={t.id} value={t.id}>{t.name}</option>)}
                            </select>
                        </div>
                        <div className="w-40"><label className="block text-xs font-semibold text-gray-500 uppercase mb-1">Start Date</label><input type="date" value={dateRange.start} min={minMaxDate.min} max={minMaxDate.max} onChange={e => setDateRange(prev => ({...prev, start: e.target.value}))} className="block w-full border-gray-300 rounded-md shadow-sm py-2 border px-2" /></div>
                        <div className="w-40"><label className="block text-xs font-semibold text-gray-500 uppercase mb-1">End Date</label><input type="date" value={dateRange.end} min={minMaxDate.min} max={minMaxDate.max} onChange={e => setDateRange(prev => ({...prev, end: e.target.value}))} className="block w-full border-gray-300 rounded-md shadow-sm py-2 border px-2" /></div>
                        
                        <button onClick={() => setIsPreviewMode(!isPreviewMode)} className={`flex items-center gap-2 px-4 py-2 rounded-md shadow-sm font-medium transition-colors ${isPreviewMode ? 'bg-red-100 text-red-700 border border-red-200 hover:bg-red-200' : 'bg-indigo-600 text-white hover:bg-indigo-700'}`}>
                            {isPreviewMode ? <><Icons.Stop /> Stop Animation</> : <><Icons.Play /> Preview Animation</>}
                        </button>
                    </div>

                    <div className="bg-[radial-gradient(circle_at_center,_var(--tw-gradient-stops))] from-white via-slate-100 to-slate-300 border border-gray-200 rounded-xl shadow-sm h-[800px] relative overflow-hidden">
                         <div className="absolute top-4 left-4 z-10 pointer-events-none">
                            <h3 className="text-lg font-bold text-gray-900">Passing Network {isPreviewMode && "(Live Preview)"}</h3>
                            <p className="text-sm text-gray-500">{teams.find(t => t.id === selectedTeamId)?.name} | {graphData.nodes.length} Players | {graphData.links.length} Connections</p>
                        </div>
                        
                        {!isPreviewMode && (
                        <div className="absolute top-4 right-4 z-10 flex flex-col gap-4 items-end pointer-events-auto">
                            <div className="bg-white/90 p-4 rounded-lg shadow-sm border border-gray-200 w-64">
                                <div className="flex justify-between items-center mb-3">
                                    <div className="flex items-center gap-2 text-sm font-bold text-gray-700"><Icons.Rotate3D /> 3D Controls</div>
                                    <button onClick={() => setAutoRotate(!autoRotate)} className={`text-xs px-2 py-1 rounded ${autoRotate ? 'bg-blue-100 text-blue-600' : 'bg-gray-100'}`}>{autoRotate ? 'Stop' : 'Auto'}</button>
                                </div>
                                <div className="space-y-3">
                                    <div className="flex items-center gap-2 text-xs"><span className="w-4 font-bold text-gray-500">X</span><input type="range" min="-90" max="90" value={rotation.x} onChange={e => setRotation({...rotation, x: Number(e.target.value)})} className="flex-1 h-1 bg-gray-200 rounded-lg cursor-pointer" /><span className="w-6 text-right">{rotation.x}Â°</span></div>
                                    <div className="flex items-center gap-2 text-xs"><span className="w-4 font-bold text-gray-500">Y</span><input type="range" min="0" max="360" value={rotation.y} onChange={e => setRotation({...rotation, y: Number(e.target.value)})} className="flex-1 h-1 bg-gray-200 rounded-lg cursor-pointer" /><span className="w-6 text-right">{Math.round(rotation.y)}Â°</span></div>
                                    <div className="flex items-center gap-2 text-xs"><span className="w-4 font-bold text-gray-500">Z</span><input type="range" min="0" max="360" value={rotation.z} onChange={e => setRotation({...rotation, z: Number(e.target.value)})} className="flex-1 h-1 bg-gray-200 rounded-lg cursor-pointer" /><span className="w-6 text-right">{rotation.z}Â°</span></div>
                                    <button onClick={resetRotation} className="w-full text-xs bg-gray-50 hover:bg-gray-100 py-1 rounded border text-gray-500">Reset View</button>
                                </div>
                            </div>
                            <div className="text-xs text-gray-500 space-y-1 text-right bg-white/90 p-3 rounded shadow-sm border border-gray-100 w-fit">
                                <div className="flex items-center justify-end gap-2 font-medium mb-1">Legend</div>
                                <div className="flex items-center justify-end gap-2">Outgoing Pass <span className="w-3 h-3 rounded-full bg-green-500"></span></div>
                                <div className="flex items-center justify-end gap-2">Incoming Pass <span className="w-3 h-3 rounded-full bg-red-500"></span></div>
                            </div>
                        </div>
                        )}

                        {loading && <div className="absolute inset-0 bg-white/80 z-10 flex items-center justify-center"><div className="flex flex-col items-center gap-2 text-blue-600"><Icons.Loader /><span className="font-medium">Processing Data...</span></div></div>}

                        {fetchError && (
                            <div className="absolute inset-0 bg-white/95 z-20 flex items-center justify-center">
                                <div className="flex flex-col items-center gap-4 p-8 bg-white rounded-xl shadow-lg border border-gray-200 max-w-md text-center">
                                    <div className="text-red-500"><Icons.AlertCircle /></div>
                                    <h3 className="text-lg font-bold text-gray-900">Cannot Load Data from GitHub</h3>
                                    <p className="text-sm text-gray-500">Your network seems to be blocking raw GitHub user content. Please upload the dataset manually to continue.</p>
                                    <div className="w-full pt-4 border-t border-gray-100">
                                        <p className="text-xs font-semibold text-gray-600 mb-2">Required File: all_players_pass_data_{selectedYear}.csv</p>
                                        <label className="flex flex-col items-center justify-center w-full h-32 border-2 border-blue-300 border-dashed rounded-lg cursor-pointer bg-blue-50 hover:bg-blue-100">
                                            <div className="flex flex-col items-center justify-center pt-5 pb-6"><Icons.Upload /><p className="mb-2 text-sm text-gray-500"><span className="font-semibold">Click to upload</span></p></div>
                                            <input type="file" className="hidden" accept=".csv" onChange={handleFileUpload} />
                                        </label>
                                    </div>
                                </div>
                            </div>
                        )}

                        <div className="w-full h-full cursor-move">
                            {graphData.nodes.length > 0 ? <svg ref={svgRef} viewBox="0 0 1000 800" className="w-full h-full"></svg> : !loading && !fetchError && <div className="flex items-center justify-center h-full text-gray-400 flex-col gap-2"><Icons.Network /><p>No data found for current filters.</p></div>}
                        </div>
                    </div>
                </div>
            );
        };

        // --- App Component ---
        const App = () => {
            const [activeTab, setActiveTab] = useState('explorer');
            return (
                <div className="min-h-screen bg-gray-100 p-4 md:p-8 font-sans">
                    <div className="max-w-7xl mx-auto flex flex-col bg-white/50 border border-gray-200 rounded-xl shadow-xl backdrop-blur-sm overflow-hidden min-h-[calc(100vh-4rem)]">
                        <div className="bg-white border-b border-gray-200 px-6 py-4 flex items-center justify-between sticky top-0 z-50">
                            <div className="flex items-center gap-3">
                                <div className="p-2 bg-gradient-to-br from-blue-500 to-indigo-600 text-white rounded-lg shadow-md"><Icons.Database /></div>
                                <div><h1 className="text-xl font-bold text-gray-900">NBA Analytics Hub</h1><p className="text-xs text-gray-500">Passing Network & Performance Data</p></div>
                            </div>
                            <div className="flex bg-gray-100 p-1 rounded-lg">
                                <button onClick={() => setActiveTab('explorer')} className={`px-4 py-2 text-sm font-medium rounded-md transition-all flex items-center gap-2 ${activeTab === 'explorer' ? 'bg-white text-blue-600 shadow-sm' : 'text-gray-500 hover:text-gray-700'}`}><Icons.FileText /> Data Explorer</button>
                                <button onClick={() => setActiveTab('network')} className={`px-4 py-2 text-sm font-medium rounded-md transition-all flex items-center gap-2 ${activeTab === 'network' ? 'bg-white text-blue-600 shadow-sm' : 'text-gray-500 hover:text-gray-700'}`}><Icons.Network /> Network Builder</button>
                            </div>
                        </div>
                        <div className="p-6 bg-white flex-1 overflow-y-auto">
                            {activeTab === 'explorer' ? <DataExplorer /> : <NetworkVisualizer />}
                        </div>
                    </div>
                </div>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>
